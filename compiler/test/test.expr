type myInt = int

struct AnotherOne = {
  bool abc = true
}

struct myStruct = {
  int i = 10
  string something = "something"
  AnotherOne ayy
}

func something() {
  myStruct s = {
    i = 100 * 7 / 3
    something = "else"
    ayy = {
      abc = true
    }
  }

  int i = 10

  // Functions do not have to be pre-defined
  another(i, "s")
}

/*
  The main function does not require a return type;
  It can only accept `int` as the return type and
  will automatically be injected if not supplied
*/
func main() {
  // Cannot set member variables yet
  object o = {}

  enum {
    some
    one = some + 2
    here
  }

  if 69 > one + 20 {
    int x = 7
  } else if some {
    var y = "1000000" + true
  } else {
    launch something()
  }


  launch something()

  defer something()

  string thing = "thing"
  string nothing = "nothing"

  map m = {
    thing : 6
    "not_a_thing" : nothing
    6 : true
    false : "thing"
  }

  // Compiler cannot squash types right now so maps have unravel into vars
  var m_thing = m[thing]

  int a = 0
  int* b = &a
  int c = *b

  int i = 800008

  for j in [1,2,3] {
    i = j
  }
  int k = 10

  for j in [1,2,3] {
    for j in [4,5,6] {
      i = j
    }
  }

  // Functions do not have to be pre-defined
  something()
}

func another(int i, string s) {
  int j = 6666666
}